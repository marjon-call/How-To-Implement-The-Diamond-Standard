# How-To-Implement-The-Diamond-Standard
The Diamond Standard, EIP-2535, was created by Nick Mudge as a standardized architecture for implementing proxy smart contracts. In this article we will go over the pros of using the Diamond Standard and how it works.

## General Overview
The Diamond Standard operates by deploying a contract called ```Diamond.sol```. ```Diamond.sol```, then calls other smart contracts via ```delegatecall()```. This allows ```Diamond.sol``` to execute the code of the called contract in the context of ```Diamond.sol```. All contracts that are called with ```delegatecall()``` are referred to as facets. Facets can be replaced, removed, and added as time goes on, which allows developers to create modular apps on EVM compatible blockchains. The Diamond Standard requires you to implement  ```DiamondLoupeFacet.sol```. ```DiamondLoupeFacet.sol``` is in charge of documenting other facets in your protocol. ```DiamondLoupeFacet.sol``` provides transparency by allowing  users to see what the facet addresses and functions are. Another requirement of the Diamond Standard is ```DiamondCutFacet.sol```. ```DiamondCutFacet.sol``` is responsible for all upgrades to your application. ```DiamondCutFacet.sol``` also emits events when called, providing another level of transparency for users of the protocol. Although not necessarily a requirement, ```LibDiamond.sol``` is a library that provides many helper functions to write an application with the Diamond Standard. When creating an application with the Diamond Standard, you can go with one of two routes to maintain your state variables. They are referred to as ```App Storage``` and ```Diamond Storage```. We will go over all of the Diamond Standard’s components in more detail in the rest of the article.

The Diamond Standard has three different versions of implementation. Luckily, if you decide that you chose the wrong implementation, it is possible to upgrade your application to a different implementation. ```diamond-1``` is the most basic implementation. The complexity of ```diamond-1``` is the easiest to understand, and its gas costs are the most mild. It is not recommended to call ```DiamondLoupeFacet.sol```’s functions on chain with ```diamond-1``` (or ```diamond-2```), due to the intensive gas costs. ```diamond-3```, on the other hand, chooses to optimize calling ```DiamondLoupeFacet.sol```’s functions on chain. The trade off is that it is more costly to call ```DiamondCutFacet.sol```. ```diamond-2``` is very similar to ```diamond-1```, but optimizes gas costs over complexity to understand. It is up to you, as a developer, to decide which one of these implementations is the best fit for your application.

Due to the complexity of the Diamond Standard, it is recommended to follow a general template when creating your applications. I will link these templates at the bottom of the article along with further reading materials.

## Why Use The Diamond Standard?
The main criticism of the Diamond Standard is its complexity (hopefully I can help solve this). Although it is complex, the Diamond Standard provides the following benefits: <br>
- There is no practical limit to the size of your application. All smart contracts have a maximum size of 24KB. Since the Diamond Standard uses ```Diamond.sol``` to ```delegatecall()``` its facets, the size of the contract remains relatively small. <br>
- You only use one address for a multitude of functionality. Again, thanks to ```delegatecall()```, you can add all the functionality you want to a single smart contract. This includes implementing tokens with the same address as your protocol. <br>
- It provides an organized way to upgrade your smart contracts. This can help auditors to understand and protect your application. <br>
- It allows you to upgrade your smart contracts incrementally. Instead of having to redeploy your entire contract, you can simply add, replace, or remove a facet to provide the desired functionality to your application. <br>
- It provides a great level of transparency for your proxy contract. As previously mentioned, ```DiamondLoupeFacet.sol``` allows users to see where your functions are located on the blockchain and what your functions execute. Check out https://louper.dev/ to analyze the functionality of smart contracts that take advantage of the Diamond Standard. <br>
- There is nearly no limit to the amount of facets that can be utilized in your application. The only way that you would not be able to add more facets to your protocol would be if ```Diamond.sol``` ran out of space to store the facet data. This would need a ridiculously large amount of facets, to the point it is practically impossible. <br>
- Facets can be reused by multiple ```Diamond.sol``` contracts. This allows you to save gas costs when deploying applications that borrow functionality. <br>
- You can run the optimizer at a higher runs setting if desired. The Solidity optimizer helps to optimize the gas costs when calling external functions. However, it increases the contract deployment bytecode. This can cause your smart contract to go over the max smart contract size limit. Since you can deploy as many facets as you want, you can set the optimizer to as high of a number of runs you desire without having to worry about your contract being too large. <br>

There are many reasons why you would want to use the Diamond Standard in your application, but remember not to over complicate your application. If your protocol can work with a single smart contract and none of the above benefits apply to your application there is no need to use the Diamond Standard. It will just end up adding more complexity and gas costs to your application. However, if you are in the situation where you need a proxy pattern for your application, I personally recommend using the Diamond Standard.
